### \==和equals()
 - \==判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址)
 - equals()是对象重新覆盖重写的方法，想怎样写都行
 - 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。
 <br>
 ![1](./image/1.jpg)

 ### hashCode()与 equals()
 - hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置.
 - equals()是对象重新覆盖重写的方法，想怎样写都行
 - 对于集合类元素来说，HashMap的put()方法实际上是先调用hashCode()定位到数组的**大致**位置,如果只重写了equals()方法
 - 对于对象集合的判重，用equals()性能太差
 - equals方法与hashCode方法根本就是**配套使用的**。对于任何一个对象，不论是使用继承自Object的equals方法还是重写equals方法。hashCode方法实际上必须要完成的一件事情就是，为该equals方法认定为相同的对象返回相同的哈希值。
 - hashCode方法的重写原则就是保证equals方法认定为相同的两个对象拥有相同的哈希值
  - 被String类中的equals方法认定为相等的两个对象拥有两个不同的哈希值（因为他们的地址值不同）

  ### HashMap
 ![5](./image/5.png)
- HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题
- Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold = length * Load factor。超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。
- 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考这篇文章，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。
- 即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树
 ![6](./image/6.jpg)
 - 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算
 - 我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的.它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。
 ![3](./image/3.png)
 <br>
 ![4](./image/4.png)
 - 经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置
 ![2](./image/2.png)

 ### 双重锁实现单例模式
```
 public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
 }
```

## Synchronized集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？
- SynchronizedList
- CopyOnWriteArrayList

## 简述 BIO, NIO, AIO 的区别
- 这里只考虑两个实体（客户端、服务端），一个事件（客户端向服务端请求数据）。同步、异步描述的是：客户端在请求数据的过程中，能否做其他事情。
- 阻塞、非阻塞描述的是：客户端与服务端是否从头到尾始终都有一个持续连接，以至于占用了通道，不让其他客户端成功连接。
- BIO（同步阻塞）：客户端在请求数据的过程中，保持一个连接，不能做其他事情。
- NIO（同步非阻塞）：客户端在请求数据的过程中，不用保持一个连接，不能做其他事情。（不用保持一个连接，而是用许多个小连接，也就是轮询）
- AIO（异步非阻塞）：客户端在请求数据的过程中，不用保持一个连接，可以做其他事情。（客户端做其他事情，数据来了等服务端来通知。）

## 实现单例设计模式（懒汉，饿汉）
- 饿汉
```
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton newInstance(){
        return instance;
    }
}
```
- 懒汉
```
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton newInstance(){
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

## 简述 Java 的反射机制及其应用场景
- 简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。
- 框架配置文件
- 加载数据库驱动


## 简述动态代理与静态代理
- 静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。
- JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。
动态代理生成的类为 lass com.sun.proxy.\Proxy4，cglib代理生成的类为class com.cglib.UserDao\\EnhancerByCGLIB\\$552188b6。
- 静态代理在编译时产生class字节码文件，可以直接使用，效率高。
- 动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。
- cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。
- 因为字节码是invokeinterface+目标接口方法。运行时去虚化，把目标方法的字符引用转为动态代理类的方法。
- 这个问题我追过。其实就是设计思想，而非什么功能设计。你去看看jdk里proxy这个类的第一段说明就知道了。proxy中的方法，被设计为所有代理类的通用方法，而java又只能单继承，所以造成了一些矛盾的现象，导致jdk动态代理只能代理接口。

## Java 中接口和抽象类的区别
- 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
- 人脑承受复杂性
- 什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。

## 简述装饰器模式以及适配器模式
- 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
- 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
- 装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
- 适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。

## 在一个静态方法内调用一个非静态成员为什么是非法的？
- 类的静态成员(变量或方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问
非静态成员(变量或方法)属于类的对象，只有在类的对象产生(实例化)时才会分配内存，然后通过类的对象(实例)去访问。所以，如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员可能不存在，访问一个内存中不存在的东西当然会出错

## 手写生产者消费者模型

## 工厂模式